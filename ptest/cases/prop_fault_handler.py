from .base import SingleSatOnlyCase
from .utils import FSWEnum, Enums, TestCaseFailure, BootUtil

# pio run -e fsw_native_leader
# python -m ptest runsim -c ptest/configs/ci.json -t PropFaultHandler
class PropFaultHandler(SingleSatOnlyCase):

    # constants
    MAX_SAFE_PRESSURE = 75
    MAX_SAFE_TEMP = 48

    @property
    def sim_duration(self):
        return float("inf")

    @property
    def initial_state(self):
        return "follower" # follower because follower is the one that moves

    @property
    def fast_boot(self):
        return True

    def setup_post_bootsetup(self):
        self.ws("fault_handler.enabled", True)
        self.sim.flight_controller.write_state("dcdc.SpikeDock_cmd", True)
        self.sim.flight_controller.write_state(
            "prop.state", Enums.prop_states["disabled"])
        self.cycle()

    def collect_diagnostic_data(self):
        self.rs("prop.state")
        self.rs("pan.state")
        self.powercycle_happening = self.rs("gomspace.power_cycle_output3_cmd")
        self.rs("pan.cycle_no")

    # --------------------------------------------------------------------------------------
    # This section is autogenerated by ./pan_generate prop /home/athena/PAN/FlightSoftware/src/fsw/FCCode/PropFaultHandler.cpp
    # --------------------------------------------------------------------------------------

    @property
    def state(self):
        return str(self.read_state("prop.state"))

    @state.setter
    def state(self, val):
        self.ws("prop.state", str(Enums.prop_states[val]))

    @property
    def max_venting_cycles(self):
        return str(self.read_state("prop.max_venting_cycles"))

    @max_venting_cycles.setter
    def max_venting_cycles(self, val):
        self.write_state("prop.max_venting_cycles", str(val))

    @property
    def overpressured_base(self):
        return str(self.read_state("prop.overpressured.base"))

    @overpressured_base.setter
    def overpressured_base(self, val):
        self.write_state("prop.overpressured.base", str(val))

    @property
    def pressurize_fail_base(self):
        return str(self.read_state("prop.pressurize_fail.base"))

    @pressurize_fail_base.setter
    def pressurize_fail_base(self, val):
        self.write_state("prop.pressurize_fail.base", str(val))

    @property
    def tank2_temp_high_base(self):
        return str(self.read_state("prop.tank2_temp_high.base"))

    @tank2_temp_high_base.setter
    def tank2_temp_high_base(self, val):
        self.write_state("prop.tank2_temp_high.base", str(val))

    @property
    def tank1_temp_high_base(self):
        return str(self.read_state("prop.tank1_temp_high.base"))

    @tank1_temp_high_base.setter
    def tank1_temp_high_base(self, val):
        self.write_state("prop.tank1_temp_high.base", str(val))

    # --------------------------------------------------------------------------------------
    # This section is partially copied from PropStateMachineCase
    # --------------------------------------------------------------------------------------

    @property
    def cycles_until_firing(self):
        return str(self.read_state("prop.cycles_until_firing"))

    @cycles_until_firing.setter
    def cycles_until_firing(self, val):
        self.write_state("prop.cycles_until_firing", str(val))

    @property
    def sched_valve1(self):
        return str(self.read_state("prop.sched_valve1"))

    @sched_valve1.setter
    def sched_valve1(self, val):
        self.write_state("prop.sched_valve1", str(val))

    @property
    def sched_valve2(self):
        return str(self.read_state("prop.sched_valve2"))

    @sched_valve2.setter
    def sched_valve2(self, val):
        self.write_state("prop.sched_valve2", str(val))

    @property
    def sched_valve3(self):
        return str(self.read_state("prop.sched_valve3"))

    @sched_valve3.setter
    def sched_valve3(self, val):
        self.write_state("prop.sched_valve3", str(val))

    @property
    def sched_valve4(self):
        return str(self.read_state("prop.sched_valve4"))

    @sched_valve4.setter
    def sched_valve4(self, val):
        self.write_state("prop.sched_valve4", str(val))

    @property
    def sched_intertank1(self):
        return str(self.read_state("prop.sched_intertank1"))

    @sched_intertank1.setter
    def sched_intertank1(self, val):
        self.write_state("prop.sched_intertank1", str(val))

    @property
    def sched_intertank2(self):
        return str(self.read_state("prop.sched_intertank2"))

    @sched_intertank2.setter
    def sched_intertank2(self, val):
        self.write_state("prop.sched_intertank2", str(val))

    @property
    def max_pressurizing_cycles(self):
        return str(self.read_state("prop.max_pressurizing_cycles"))

    @max_pressurizing_cycles.setter
    def max_pressurizing_cycles(self, val):
        self.write_state("prop.max_pressurizing_cycles", str(val))

    @property
    def threshold_firing_pressure(self):
        return str(self.read_state("prop.threshold_firing_pressure"))

    @threshold_firing_pressure.setter
    def threshold_firing_pressure(self, val):
        self.write_state("prop.threshold_firing_pressure", str(val))

    @property
    def ctrl_cycles_per_filling(self):
        return str(self.read_state("prop.ctrl_cycles_per_filling"))

    @ctrl_cycles_per_filling.setter
    def ctrl_cycles_per_filling(self, val):
        self.write_state("prop.ctrl_cycles_per_filling", str(val))

    @property
    def ctrl_cycles_per_cooling(self):
        return str(self.read_state("prop.ctrl_cycles_per_cooling"))

    @ctrl_cycles_per_cooling.setter
    def ctrl_cycles_per_cooling(self, val):
        self.write_state("prop.ctrl_cycles_per_cooling", str(val))

    @property
    def tank1_valve_choice(self):
        return str(self.read_state("prop.tank1.valve_choice"))

    @tank1_valve_choice.setter
    def tank1_valve_choice(self, val):
        self.write_state("prop.tank1.valve_choice", str(val))

    @property
    def tank2_pressure(self):
        return str(self.read_state("prop.tank2.pressure"))

    @tank2_pressure.setter
    def tank2_pressure(self, val):
        self.write_state("prop.tank2.pressure", str(val))

    @property
    def tank2_temp(self):
        return str(self.read_state("prop.tank2.temp"))

    @tank2_temp.setter
    def tank2_temp(self, val):
        self.write_state("prop.tank2.temp", str(val))

    @property
    def tank1_temp(self):
        return str(self.read_state("prop.tank1.temp"))

    @tank1_temp.setter
    def tank1_temp(self, val):
        self.write_state("prop.tank1.temp", str(val))

    def print_object(self):
        print(f"[TESTCASE] state: {self.state}")
        print(f"[TESTCASE] max_venting_cycles: {self.max_venting_cycles}")
        print(f"[TESTCASE] overpressured_base: {self.overpressured_base}")
        print(f"[TESTCASE] pressurize_fail_base: {self.pressurize_fail_base}")
        print(f"[TESTCASE] tank2_temp_high_base: {self.tank2_temp_high_base}")
        print(f"[TESTCASE] tank1_temp_high_base: {self.tank1_temp_high_base}")
        print(f"[TESTCASE] tank2_pressure: {self.tank2_pressure}")
        print(f"[TESTCASE] tank2_temp: {self.tank2_temp}")
        print(f"[TESTCASE] tank1_temp: {self.tank1_temp}")

    # --------------------------------------------------------------------------------------
    # Helper methods for the prop state machine
    # --------------------------------------------------------------------------------------

    @property
    def min_num_cycles(self):
        return (int(self.ctrl_cycles_per_filling) + int(self.ctrl_cycles_per_cooling))*int(self.max_pressurizing_cycles) + 4

    def cycle_until_change(self, max_cycles=0, f=None):
        if max_cycles == 0:
            max_cycles = self.min_num_cycles
        old_state = self.state
        for i in range(int(max_cycles)):
            if f != None:
                f()
            if self.state != old_state:
                return str(i)
            else:
                self.cycle()
        return str(-1)

    def goto_idle(self):
        self.state = "idle"
        self.cycle()
        self.check_prop_state("idle")
    
    def goto_await_pressurizing(self):
        self.goto_idle()
        self.sched_valve1 = 100
        self.sched_valve2 = 700
        self.sched_valve3 = 800
        self.sched_valve4 = 400
        self.cycles_until_firing = int(self.min_num_cycles) + 2
        self.cycle()
        self.check_prop_state("await_pressurizing")

    def goto_pressurize(self):
        self.goto_await_pressurizing()
        self.cycle_until_change()
        self.check_prop_state("pressurizing")

    def goto_await_firing(self):
        self.goto_pressurize()
        self.cycle_until_change()
        self.check_prop_state("await_firing")

    def goto_firing(self):
        self.goto_await_firing()
        self.cycle_until_change()
        self.check_prop_state("firing")

    # --------------------------------------------------------------------------------------
    # Helper methods for tests
    # --------------------------------------------------------------------------------------

    def check_mission_state(self, expected, reason=""):
        if self.mission_state != expected:
            raise TestCaseFailure(
                f"Expected mission_state = {expected}, but mission_state = {self.mission_state}. Reason: {reason}")
    
    def check_prop_state(self, expected, reason=""):
        if self.state != str(Enums.prop_states[expected]):
            raise TestCaseFailure(
                f"Expected prop.state = {Enums.prop_states[expected]}, but prop.state = {self.state}. Reason: {reason}")
    
    def check_is_faulted(self, fault_name, expected="true"):
        if self.read_state(fault_name) != expected:
            raise TestCaseFailure(
                f"Expected fault {fault_name} to be {expected}")

    # --------------------------------------------------------------------------------------
    # PropFaultHandler Tests
    # --------------------------------------------------------------------------------------

    def sanity_test(self):
        self.check_mission_state("follower", "Sanity check")
        self.check_prop_state("disabled", "Sanity check: prop state should be in disabled")
        if not self.read_state("dcdc.SpikeDock") == "true":
            raise TestCaseFailure("Spike and Hold DCDC is not enabled.")

    def simulate_overpressure(self):
        self.tank2_pressure = self.MAX_SAFE_PRESSURE + 1
        self.print_object()

    def test_pressurize_fail(self):
        self.goto_idle()
        self.pressurize_fail_base = True
        self.cycle()
        # HERE: 
        # expect to go into hnadling_fault very soon since the persistence on this is 0
        self.check_prop_state("handling_fault", 
            "should go into handling fault after 1 cycle since persistence is 0 for pressurize_fail_fault_f")


    def overpressure_causes_standby(self):
        self.goto_idle()
        self.cycle_until_change(f=self.simulate_overpressure)

        # self.goto_pressurize()
        # self.cycle()
        # self.check_prop_state("pressurizing", "Should still be pressurizing")
        # # Set the tank2 pressure high
        # self.tank2_pressure = self.MAX_SAFE_PRESSURE + 1
        # self.cycle()
        # self.check_prop_state("await_firing", "should be in await_firing since pressure is high")
        # self.check_mission_state("follower", "mission state should still be in follower since fault is not yet set")
        # self.check_is_faulted("prop.overpressured.base", "false")
        # self.cycle_until_change(f=self.simulate_overpressure)

        # Prop should now be handling fault
        self.check_is_faulted("prop.overpressured.base", "true")
        self.check_prop_state("handling_fault", "Should be handling fault because pressure is too high")
        self.check_mission_state("standby", "mission state should be in standby when prop is handling fault")
        self.cycle()
        self.check_prop_state("venting", "Prop should be venting now since overpressue fault is set")
        self.check_mission_state("standby", "mission state should be in standby when prop is venting")
        self.cycle_until_change(f=self.print_object)

    def run_case_singlesat(self):
        if not self.finished:
            self.collect_diagnostic_data()

        # Sanity check
        self.sanity_test()

        # Check that when prop is overpressured, mission state goes into standby
        self.test_pressurize_fail()
        self.overpressure_causes_standby()

        self.finish()

    
        

